# Address Derivation

---

## Mnemonic Phrase

### Encoding

Cardano uses the same process laid out in [BIP-0039](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) for randomly generating  mnemonic phrases from entropy.

We call _Entropy_ an arbitrary sequence of bytes that has been generated through high quality randomness methods. The allowed size of _Entropy_ is 96-256 bits and is necessarily a multiple of 32 bits (4 bytes).

A relatively easy was to generate an entropy bytestring would be to use the [System.Entropy](https://hackage.haskell.org/package/entropy) from Hackage. This will provide entropy through the platform's underlying generator. But this has a high overhead on systems without the RDRAND instruction - it has to open a file, read, and close the file.

```haskell
import System.Entropy

someFunc = do
    seed <- getEntropy 32		-- Number of bytes as input.
    ....
```

A checksum is appended to the initial entropy by taking the first `ENT / 32` bits of the `SHA256`hash of it, where `ENT` designates the _Entropy_ size in bits.

Then, the concatenated result is split into groups of 11 bits, each encoding a number from 0 to 2047 serving as an index into a known dictionary (see below).

| Sentence Length | Entropy Size        | Checksum Size |
| --------------- | ------------------- | ------------- |
| 9 words         | 96 bits (12 bytes)  | 3 bits        |
| 12 words        | 128 bits (16 bytes) | 4 bits        |
| 15 words        | 160 bits (20 bytes) | 5 bits        |
| 18 words        | 192 bits (24 bytes) | 6 bits        |
| 21 words        | 224 bits (28 bytes) | 7 bits        |
| 24 words        | 256 bits (32 bytes) | 8 bits        | 


### Dictionaries

Cardano uses the same dictionaries as defined in [BIP-0039](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki).

### Mnemonic to Seed

A user may decide to protect their mnemonic with a passphrase. If a passphrase is not present, an empty string "" is used instead.

To create a binary seed from the mnemonic, we use the PBKDF2 function with a mnemonic sentence used as the password and the string "mnemonic" + passphrase used as the salt. The iteration count is set to 4096 and HMAC-SHA512 is used as the pseudo-random function. The length of the derived key is 768 bits (= 96 bytes).

In [cryptonite](https://hackage.haskell.org/package/cryptonite), the module [Crypto.KDF.PBKDF2](https://hackage.haskell.org/package/cryptonite-0.29/docs/Crypto-KDF-PBKDF2.html) has a `fastPBKDF2_SHA512` function that can be used to generate the seed.

```haskell
-- From IOHK cardano-crypto: Cardano.Crypto.Wallet

import Crypto.KDF.PBKDF2 		(fastPBKDF2_SHA512, Parameters(..))
import Data.ByteArray 			(ByteArrayAccess)

out :: (ByteArrayAccess generationPassPhrase, ByteArrayAccess seed)
	=> seed -- ^ Raw entropy used as source of randomness for this algorithm
	-> generationPassPhrase -- ^ User chosen passphrase for the generation phase
	-> ByteString
out genPassPhrase seed = fastPBKDF2_SHA512 (Parameters 4096 96) genPassPhrase seed
```

The conversion of the mnemonic sentence to a binary seed is completely independent from generating the sentence. This results in a rather simple code; there are no constraints on sentence structure and clients are free to implement their own wordlists or even whole sentence generators, allowing for flexibility in wordlists for typo detection or other purposes.

Although using a mnemonic not generated by the algorithm described in "Generating the mnemonic" section is possible, this is not advised and software must compute a checksum for the mnemonic sentence using a wordlist and issue a warning if it is invalid.

The described method also provides plausible deniability, because every passphrase generates a valid seed (and thus a deterministic wallet) but only the correct one will make the desired wallet available.

---

## Key Derivation

The mnemonic phrase will first be converted into a hexadecimal bytestring, which can be done with CBOR. But, the bits of the check sum that were appended to the end of the string, when generating the mnemonic phrase, shall be removed.

The new bytesting is put through a hashing algorithm, PBKDF2 with HMAC-SHA512. The resulting key is expected have a length 96 bytes.

[CIP-0003](https://github.com/cardano-foundation/CIPs/blob/master/CIP-0003/CIP-0003.md)

### Root Key

There are two main categories of keys in this library. There are the raw `PublicKey` and `PrivateKey` which are used for cryptographically signing/verifying, and `BIP32PrivateKey`/`BIP32PublicKey` which in addition to this have the ability to derive additional keys from them following the [BIP-0032](https://en.bitcoin.it/wiki/BIP_0032) variant called [BIP32-Ed25519](https://github.com/input-output-hk/adrestia/blob/master/user-guide/static/Ed25519_BIP.pdf), which will be referred to as BIP32 for brevity. 

The root key generation is the mean by which one turns an initial entropy into a secure cryptographic key. Child keys can be derived from a master key to produce an HD structure, as outlined above. Child key derivation is explored in next sections.

In Cardano, the root key generation is different depending on which style of wallet one is considering. In each case however, the generation is a function from an initial seed to an extended private key (abbrev. XPrv) composed of:

-   64 bytes: an extended Ed25519 secret key composed of:
    -   32 bytes: Ed25519 curve scalar from which few bits have been tweaked (see below)
    -   32 bytes: Ed25519 binary blob used as IV for signing
-   32 bytes: chain code for allowing secure child key derivation

### Extended Private Key & Root Chain Code
 
 This process is directly from BIP32:
 
The private key `~k` is a 32-byte cryptographically-secure random value. The public key `A` is derived as follows:
1.  Let `H512()` be SHA512. Hash the 32-byte private key `~k` using `H512`, storing the digest in a 64-byte buffer, denoted `k`. We call `k` an extended private key. Split `k` into the lower 32 bytes `kL` and upper 32 bytes `kR`.
2.  Modify `kL`: the lowest 3 bits of the first byte of are cleared, the highest bit of the last byte is cleared, and the second highest bit of the last byte is set.
3.  Interpret `kL` as a little-endian integer and perform a fixed-base scalar multiplication `[kL]B`.
4.  The public key `A` is the encoding of the point `[kL]B` as follows. First encode the y coordinate (in the range 0 â‰¤ y < p) as a little-endian string of 32 octets. The most significant bit of the final octet is always zero. To form the encoding of the point `[kL]B`, copy the least significant bit of the x coordinate to the most significant bit of the final octet. The result is the public key.

### Code

From seed to extended private key through Ed25519:

```haskell
-- From IOHK cardano-addresses: Cardano.Address.Derivation

import Prelude

import Crypto.Error
	( eitherCryptoError )
import Data.Either.Extra
	( eitherToMaybe )

import qualified Crypto.ECC.Edwards25519 as Ed25519
import qualified Data.ByteString as BS

xprvFromBytes :: ByteString -> Maybe XPrv
xprvFromBytes bytes
    | BS.length bytes /= 96 = Nothing
    | otherwise = do
		let (prv, cc) = BS.splitAt 64 bytes
		pub <- ed25519ScalarMult (BS.take 32 prv)
		eitherToMaybe $ CC.xprv $ prv <> pub <> cc		-- CC is cardano-crypto, which is an IOHK proprietary package.
  where
	ed25519ScalarMult :: ByteString -> Maybe ByteString
	ed25519ScalarMult bs = do
		scalar <- eitherToMaybe $ eitherCryptoError $ Ed25519.scalarDecodeLong bs
		pure $ Ed25519.pointEncode $ Ed25519.toPoint scalar
```



```haskell
-- From IOHK cardano-crypto: Cardano.Crypto.Wallet

import Basement.Compat.Typeable
import Control.DeepSeq 				(NFData)
import Data.ByteArray 				(ByteArrayAccess, convert)

newtype XPrv = XPrv EncryptedKey
	deriving (NFData, Typeable, ByteArrayAccess)

xprv :: ByteArrayAccess bin => bin -> Either String XPrv
xprv bs =
	maybe (Left "error: xprv needs to be 128 bytes") (Right . XPrv)
  $ encryptedKey
  $ convert bs
```

Check to see if the key is the correct size:

```haskell
-- From cardano-crypto: Cardano.Crypto.Wallet.Encrypted

import qualified Data.ByteArray as B

totalKeySize :: Int
totalKeySize = encryptedKeySize + publicKeySize + ccSize

encryptedKeySize :: Int
encryptedKeySize = 64

publicKeySize :: Int
publicKeySize = 32

ccSize :: Int
ccSize = 32

newtype EncryptedKey = EncryptedKey ByteString
	deriving (NFData, ByteArrayAccess)

encryptedKey :: ByteString -> Maybe EncryptedKey
encryptedKey ba
    | B.length ba == totalKeySize = Just $ EncryptedKey ba
    | otherwise = Nothing
```


Additional resources:
-   [SLIP-0010](https://github.com/satoshilabs/slips/blob/master/slip-0010.md)
-   [SLIP-0023](https://github.com/satoshilabs/slips/blob/master/slip-0023.md)
-   [SLIP-0039](https://github.com/satoshilabs/slips/blob/master/slip-0039.md)
-   [Adrestia Documentation](https://input-output-hk.github.io/adrestia/docs/key-concepts/hierarchical-deterministic-wallets/)
-   [RFC 8032](https://tools.ietf.org/html/rfc8032#section-5.1.5)
-	[Byron](https://github.com/input-output-hk/cardano-wallet/wiki/About-Address-Derivation)
-	[ED25519 on Hackage](https://hackage.haskell.org/package/ed25519)
-	https://docs.restyled.io/restyler/cryptonite-0.26/Crypto-ECC-Edwards25519.html

---

## Hierarchical Deterministic Wallets

We use the [BIP-0044 spec](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki) variant for Ed25519 as well for the derivation paths using `1852` or `44` as the purpose constant and `1815` for the coin type depending on address type. See [CIP-1852](https://cips.cardano.org/cips/cip1852/) for more details.

In the _Byron_ era, sequential wallets used in Yoroi (a.k.a Icarus wallets) have been using `purpose = 44_H` according to standard BIP-0044 wallets. The _Shelley_ era introduces however an extension to BIP-44, and therefore, uses a different `purpose` number.

`1852` was chosen as it is the year of death of Ada Lovelace (following the fact that the `coin_type` value for Cardano is `1815` for her year of birth)

### Path Levels

Cardano wallet defines the following path levels:

root/purpose_H/coin_type_H/account_H/account_type/address_index

-   purpose_H is set to 1852_H
-   coin_type_H is set to 1815_H
-   account_H is set, for now, to 0_H
-   account_type is either:
    
    -   `0` to indicate an address on the external chain, that is, an address that is meant to be public and communicated to other users.
    -   `1` to indicate an address on the internal chain, that is, an address that is meant for change, generated by a wallet software.
    -   `2` to indicate a reward account address (staking key), used for delegation ([CIP-0011](https://github.com/cardano-foundation/CIPs/blob/master/CIP-0011/CIP-0011.md)).
    
-   address_indexaddress_index is either:
    
    -   `0` if the account_typeaccount_type is `2`
    -   Anything between 0 and 231 otherwise

Wallets **MUST** implement this new scheme using the master node derivation algorithm from Icarus with sequential addressing (see [CIP-0003](https://github.com/cardano-foundation/CIPs/blob/master/CIP-0003) for more information)

### Hardening

[Harden](https://stackoverflow.com/questions/39809365/how-do-you-add-two-large-random-bytestrings-in-haskell)

```haskell
harden :: [Word8] -> [Word8] -> [Word8]
harden = byteSum 0
  where
    byteSum 0 [] [] = []
    byteSum 1 [] [] = [1]
    byteSum carry (x:xs) (y:ys) =
        let v = x + y + carry
        in v : byteSum (if v < x || v < y then 1 else 0) xs ys

main = do
    let bs1 = ...
    let bs2 = ...
    let sum = pack $ harden (unpack bs1) (unpack bs2)
```

---

## Address Structure

Common Bech32 Prefixes: [CIP-0005](https://github.com/cardano-foundation/CIPs/blob/master/CIP-0005/CIP-0005.md)

Cardano Adresses: [CIP-0019](https://github.com/cardano-foundation/CIPs/blob/master/CIP-0019/CIP-0019.md)

[Bech32](https://github.com/input-output-hk/bech32)

---

# Haskell SDK

[IOHK cardano-addresses](https://github.com/input-output-hk/cardano-addresses)

[IOHK cardano-crypto](https://github.com/input-output-hk/cardano-crypto)